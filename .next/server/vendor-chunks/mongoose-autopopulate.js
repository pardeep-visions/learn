"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mongoose-autopopulate";
exports.ids = ["vendor-chunks/mongoose-autopopulate"];
exports.modules = {

/***/ "(rsc)/./node_modules/mongoose-autopopulate/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mongoose-autopopulate/index.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function autopopulatePlugin(schema, options) {\n  const pathsToPopulate = getPathsToPopulate(schema);\n\n  let testFunction = () => true;\n  if (options != null && (Array.isArray(options.functions) || options.functions instanceof RegExp)) {\n    let _functions = options.functions;\n    if (Array.isArray(_functions)) {\n      _functions = new Set(_functions);\n\n      testFunction = v => _functions.has(v);\n    } else {\n      testFunction = v => _functions.test(v);\n    }\n  }\n\n  const autopopulateHandler = function(filter) {\n    const finalPaths = [];\n\n    if (this._mongooseOptions &&\n        this._mongooseOptions.lean &&\n        // If lean and user didn't explicitly do `lean({ autopopulate: true })`,\n        // skip it. See gh-27, gh-14, gh-48\n        !this._mongooseOptions.lean.autopopulate) {\n      return;\n    }\n\n    const options = this.options || {};\n    if (options.autopopulate === false) {\n      return;\n    }\n\n    if (options.autopopulate && options.autopopulate.maxDepth) {\n      options.maxDepth = options.autopopulate.maxDepth;\n    }\n\n    const depth = options._depth != null ? options._depth : 0;\n\n    if (options.maxDepth > 0 && depth >= options.maxDepth) {\n      return;\n    }\n\n    const numPaths = pathsToPopulate.length;\n    for (let i = 0; i < numPaths; ++i) {\n      pathsToPopulate[i].options = pathsToPopulate[i].options || {};\n      if (typeof filter === 'function' && !filter(pathsToPopulate[i].options)) {\n        continue;\n      }\n      pathsToPopulate[i].options.options = pathsToPopulate[i].options.options || {};\n\n      const newOptions = { _depth: depth + 1 };\n      if (options.maxDepth) newOptions.maxDepth = options.maxDepth;\n      Object.assign(pathsToPopulate[i].options.options, newOptions);\n\n      const optionsToUse = processOption.call(this,\n        pathsToPopulate[i].autopopulate, pathsToPopulate[i].options);\n      if (optionsToUse) {\n        // If `this` is a query, population chaining is allowed.\n        // If not, add it to an array for single population at the end.\n        if (this.constructor.name === 'Query') {\n          this.populate(optionsToUse);\n        } else {\n          finalPaths.push(optionsToUse);\n        }\n      }\n    }\n\n    return finalPaths;\n  };\n\n  if (testFunction('find')) {\n    schema.pre('find', function() { return autopopulateHandler.call(this); });\n    schema.post('find', function(res) { return autopopulateDiscriminators.call(this, res); });\n  }\n  if (testFunction('findOne')) {\n    schema.pre('findOne', function() { return autopopulateHandler.call(this); });\n    schema.post('findOne', function(res) { return autopopulateDiscriminators.call(this, res); });\n  }\n  if (testFunction('findOneAndUpdate')) {\n    schema.pre('findOneAndUpdate', function() { return autopopulateHandler.call(this); });\n    schema.post('findOneAndUpdate', function(res) { return autopopulateDiscriminators.call(this, res); });\n  }\n  if (testFunction('findOneAndDelete')) {\n    schema.pre('findOneAndDelete', function() { return autopopulateHandler.call(this); });\n    schema.post('findOneAndDelete', function(res) { return autopopulateDiscriminators.call(this, res); });\n  }\n  if (testFunction('findOneAndReplace')) {\n    schema.pre('findOneAndReplace', function() { return autopopulateHandler.call(this); });\n    schema.post('findOneAndReplace', function(res) { return autopopulateDiscriminators.call(this, res); });\n  }\n  if (testFunction('save')) {\n    schema.post('save', function() {\n      if (pathsToPopulate.length === 0) {\n        return Promise.resolve();\n      }\n      // Skip for subdocs, because we assume this function only runs on\n      // top-level documents.\n      if (typeof this.ownerDocument === 'function' && this.$isSubdocument) {\n        return Promise.resolve();\n      }\n      const finalPaths = autopopulateHandler.call(this, options => {\n        const pop = this.populated(options.path);\n        if (Array.isArray(pop)) {\n          const docVal = this.get(options.path);\n          return docVal == null ||\n            pop.length !== docVal.length ||\n            pop.some(v => v == null);\n        }\n        return true;\n      });\n      return this.populate(finalPaths);\n    });\n  }\n};\n\nfunction autopopulateDiscriminators(res) {\n  if (res == null) {\n    return;\n  }\n  if (this._mongooseOptions != null && this._mongooseOptions.lean) {\n    // If lean, we don't have a good way to figure out the discriminator\n    // schema, and so skip autopopulating.\n    return;\n  }\n  if (!Array.isArray(res)) {\n    res = [res];\n  }\n\n  const discriminators = new Map();\n  for (const doc of res) {\n    if (doc.constructor.baseModelName != null) {\n      const discriminatorModel = doc.constructor;\n      const modelName = discriminatorModel.modelName;\n\n      if (!discriminators.has(modelName)) {\n        const pathsToPopulate = getPathsToPopulate(discriminatorModel.schema).\n          filter(p => !doc.populated(p.options.path));\n\n        discriminators.set(modelName, {\n          model: discriminatorModel,\n          docs: [],\n          pathsToPopulate: pathsToPopulate\n        });\n      }\n      const modelMap = discriminators.get(modelName);\n      modelMap.docs.push(doc);\n    }\n  }\n\n  return Promise.all(Array.from(discriminators.values()).map(modelMap => {\n    const pathsToPopulate = modelMap.pathsToPopulate.\n      map(p => processOption.call(this, p.autopopulate, p.options)).\n      filter(v => !!v);\n    return modelMap.model.populate(modelMap.docs, pathsToPopulate);\n  }));\n}\n\nfunction getPathsToPopulate(schema) {\n  const pathsToPopulate = [];\n  const schemaStack = new WeakMap();\n  eachPathRecursive(schema, function(pathname, schemaType) {\n    let option;\n    if (schemaType.options && schemaType.options.autopopulate) {\n      option = schemaType.options.autopopulate;\n      pathsToPopulate.push({\n        options: defaultOptions(pathname, schemaType.options),\n        autopopulate: option\n      });\n    } else if (schemaType.options &&\n        schemaType.options.type &&\n        schemaType.options.type[0] &&\n        schemaType.options.type[0].autopopulate) {\n      option = schemaType.options.type[0].autopopulate;\n      pathsToPopulate.push({\n        options: defaultOptions(pathname, schemaType.options.type[0]),\n        autopopulate: option\n      });\n    }\n  }, null, schemaStack);\n\n  return pathsToPopulate;\n}\n\nfunction defaultOptions(pathname, v) {\n  const ret = { path: pathname, options: { maxDepth: 10 } };\n  if (v.ref != null) {\n    ret.model = v.ref;\n    ret.ref = v.ref;\n  }\n  if (v.refPath != null) {\n    ret.refPath = v.refPath;\n  }\n  return ret;\n}\n\nfunction processOption(value, options) {\n  switch (typeof value) {\n    case 'function':\n      return handleFunction.call(this, value, options);\n    case 'object':\n      return handleObject.call(this, value, options);\n    default:\n      return handlePrimitive.call(this, value, options);\n  }\n}\n\nfunction handlePrimitive(value, options) {\n  if (value) {\n    return options;\n  }\n}\n\nfunction handleObject(value, optionsToUse) {\n  // Special case: support top-level `maxDepth`\n  if (value.maxDepth != null) {\n    optionsToUse.options = optionsToUse.options || {};\n    optionsToUse.options.maxDepth = value.maxDepth;\n    delete value.maxDepth;\n  }\n  optionsToUse = Object.assign({}, optionsToUse, value);\n\n  return optionsToUse;\n}\n\nfunction handleFunction(fn, options) {\n  const val = fn.call(this, options);\n  return processOption.call(this, val, options);\n}\n\nfunction eachPathRecursive(schema, handler, path, schemaStack) {\n\n  if (schemaStack.has(schema)) {\n    return;\n  }\n  if (!path) {\n    path = [];\n  }\n  schemaStack.set(schema, true);\n\n  schema.eachPath(function(pathname, schemaType) {\n    path.push(pathname);\n    if (schemaType.schema) {\n      eachPathRecursive(schemaType.schema, handler, path, schemaStack);\n\n      if (schemaType.schema.discriminators != null) {\n        for (const discriminatorName of Object.keys(schemaType.schema.discriminators)) {\n          eachPathRecursive(\n            schemaType.schema.discriminators[discriminatorName],\n            handler,\n            path,\n            schemaStack\n          );\n        }\n      }\n    } else if (schemaType.$isMongooseArray && schemaType.$embeddedSchemaType.$isMongooseArray) {\n      while (schemaType != null && schemaType.$isMongooseArray && !schemaType.$isMongooseDocumentArray) {\n        schemaType = schemaType.$embeddedSchemaType;\n      }\n      if (schemaType != null && schemaType.$isMongooseDocumentArray) {\n        eachPathRecursive(schemaType.schema, handler, path, schemaStack);\n\n        if (schemaType.schema.discriminators != null) {\n          for (const discriminatorName of Object.keys(schemaType.schema.discriminators)) {\n            eachPathRecursive(\n              schemaType.schema.discriminators[discriminatorName],\n              handler,\n              path,\n              schemaStack\n            );\n          }\n        }\n      }\n    } else {\n      handler(path.join('.'), schemaType);\n    }\n    path.pop();\n  });\n  schemaStack.delete(schema);\n  if (schema.virtuals) {\n    Object.keys(schema.virtuals).forEach(function(pathname) {\n      path.push(pathname);\n      handler(path.join('.'), schema.virtuals[pathname]);\n      path.pop();\n    });\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UtYXV0b3BvcHVsYXRlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlELG9CQUFvQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLHdDQUF3QztBQUM1RSx3Q0FBd0Msb0RBQW9EO0FBQzVGO0FBQ0E7QUFDQSx1Q0FBdUMsd0NBQXdDO0FBQy9FLDJDQUEyQyxvREFBb0Q7QUFDL0Y7QUFDQTtBQUNBLGdEQUFnRCx3Q0FBd0M7QUFDeEYsb0RBQW9ELG9EQUFvRDtBQUN4RztBQUNBO0FBQ0EsZ0RBQWdELHdDQUF3QztBQUN4RixvREFBb0Qsb0RBQW9EO0FBQ3hHO0FBQ0E7QUFDQSxpREFBaUQsd0NBQXdDO0FBQ3pGLHFEQUFxRCxvREFBb0Q7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ29sb2JfdHJhdmVsX2FnZW5jeS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS1hdXRvcG9wdWxhdGUvaW5kZXguanM/NzIyYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXV0b3BvcHVsYXRlUGx1Z2luKHNjaGVtYSwgb3B0aW9ucykge1xuICBjb25zdCBwYXRoc1RvUG9wdWxhdGUgPSBnZXRQYXRoc1RvUG9wdWxhdGUoc2NoZW1hKTtcblxuICBsZXQgdGVzdEZ1bmN0aW9uID0gKCkgPT4gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmZ1bmN0aW9ucykgfHwgb3B0aW9ucy5mdW5jdGlvbnMgaW5zdGFuY2VvZiBSZWdFeHApKSB7XG4gICAgbGV0IF9mdW5jdGlvbnMgPSBvcHRpb25zLmZ1bmN0aW9ucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShfZnVuY3Rpb25zKSkge1xuICAgICAgX2Z1bmN0aW9ucyA9IG5ldyBTZXQoX2Z1bmN0aW9ucyk7XG5cbiAgICAgIHRlc3RGdW5jdGlvbiA9IHYgPT4gX2Z1bmN0aW9ucy5oYXModik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlc3RGdW5jdGlvbiA9IHYgPT4gX2Z1bmN0aW9ucy50ZXN0KHYpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGF1dG9wb3B1bGF0ZUhhbmRsZXIgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICBjb25zdCBmaW5hbFBhdGhzID0gW107XG5cbiAgICBpZiAodGhpcy5fbW9uZ29vc2VPcHRpb25zICYmXG4gICAgICAgIHRoaXMuX21vbmdvb3NlT3B0aW9ucy5sZWFuICYmXG4gICAgICAgIC8vIElmIGxlYW4gYW5kIHVzZXIgZGlkbid0IGV4cGxpY2l0bHkgZG8gYGxlYW4oeyBhdXRvcG9wdWxhdGU6IHRydWUgfSlgLFxuICAgICAgICAvLyBza2lwIGl0LiBTZWUgZ2gtMjcsIGdoLTE0LCBnaC00OFxuICAgICAgICAhdGhpcy5fbW9uZ29vc2VPcHRpb25zLmxlYW4uYXV0b3BvcHVsYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICBpZiAob3B0aW9ucy5hdXRvcG9wdWxhdGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYXV0b3BvcHVsYXRlICYmIG9wdGlvbnMuYXV0b3BvcHVsYXRlLm1heERlcHRoKSB7XG4gICAgICBvcHRpb25zLm1heERlcHRoID0gb3B0aW9ucy5hdXRvcG9wdWxhdGUubWF4RGVwdGg7XG4gICAgfVxuXG4gICAgY29uc3QgZGVwdGggPSBvcHRpb25zLl9kZXB0aCAhPSBudWxsID8gb3B0aW9ucy5fZGVwdGggOiAwO1xuXG4gICAgaWYgKG9wdGlvbnMubWF4RGVwdGggPiAwICYmIGRlcHRoID49IG9wdGlvbnMubWF4RGVwdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBudW1QYXRocyA9IHBhdGhzVG9Qb3B1bGF0ZS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1QYXRoczsgKytpKSB7XG4gICAgICBwYXRoc1RvUG9wdWxhdGVbaV0ub3B0aW9ucyA9IHBhdGhzVG9Qb3B1bGF0ZVtpXS5vcHRpb25zIHx8IHt9O1xuICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicgJiYgIWZpbHRlcihwYXRoc1RvUG9wdWxhdGVbaV0ub3B0aW9ucykpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBwYXRoc1RvUG9wdWxhdGVbaV0ub3B0aW9ucy5vcHRpb25zID0gcGF0aHNUb1BvcHVsYXRlW2ldLm9wdGlvbnMub3B0aW9ucyB8fCB7fTtcblxuICAgICAgY29uc3QgbmV3T3B0aW9ucyA9IHsgX2RlcHRoOiBkZXB0aCArIDEgfTtcbiAgICAgIGlmIChvcHRpb25zLm1heERlcHRoKSBuZXdPcHRpb25zLm1heERlcHRoID0gb3B0aW9ucy5tYXhEZXB0aDtcbiAgICAgIE9iamVjdC5hc3NpZ24ocGF0aHNUb1BvcHVsYXRlW2ldLm9wdGlvbnMub3B0aW9ucywgbmV3T3B0aW9ucyk7XG5cbiAgICAgIGNvbnN0IG9wdGlvbnNUb1VzZSA9IHByb2Nlc3NPcHRpb24uY2FsbCh0aGlzLFxuICAgICAgICBwYXRoc1RvUG9wdWxhdGVbaV0uYXV0b3BvcHVsYXRlLCBwYXRoc1RvUG9wdWxhdGVbaV0ub3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9uc1RvVXNlKSB7XG4gICAgICAgIC8vIElmIGB0aGlzYCBpcyBhIHF1ZXJ5LCBwb3B1bGF0aW9uIGNoYWluaW5nIGlzIGFsbG93ZWQuXG4gICAgICAgIC8vIElmIG5vdCwgYWRkIGl0IHRvIGFuIGFycmF5IGZvciBzaW5nbGUgcG9wdWxhdGlvbiBhdCB0aGUgZW5kLlxuICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5uYW1lID09PSAnUXVlcnknKSB7XG4gICAgICAgICAgdGhpcy5wb3B1bGF0ZShvcHRpb25zVG9Vc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbmFsUGF0aHMucHVzaChvcHRpb25zVG9Vc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbmFsUGF0aHM7XG4gIH07XG5cbiAgaWYgKHRlc3RGdW5jdGlvbignZmluZCcpKSB7XG4gICAgc2NoZW1hLnByZSgnZmluZCcsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXV0b3BvcHVsYXRlSGFuZGxlci5jYWxsKHRoaXMpOyB9KTtcbiAgICBzY2hlbWEucG9zdCgnZmluZCcsIGZ1bmN0aW9uKHJlcykgeyByZXR1cm4gYXV0b3BvcHVsYXRlRGlzY3JpbWluYXRvcnMuY2FsbCh0aGlzLCByZXMpOyB9KTtcbiAgfVxuICBpZiAodGVzdEZ1bmN0aW9uKCdmaW5kT25lJykpIHtcbiAgICBzY2hlbWEucHJlKCdmaW5kT25lJywgZnVuY3Rpb24oKSB7IHJldHVybiBhdXRvcG9wdWxhdGVIYW5kbGVyLmNhbGwodGhpcyk7IH0pO1xuICAgIHNjaGVtYS5wb3N0KCdmaW5kT25lJywgZnVuY3Rpb24ocmVzKSB7IHJldHVybiBhdXRvcG9wdWxhdGVEaXNjcmltaW5hdG9ycy5jYWxsKHRoaXMsIHJlcyk7IH0pO1xuICB9XG4gIGlmICh0ZXN0RnVuY3Rpb24oJ2ZpbmRPbmVBbmRVcGRhdGUnKSkge1xuICAgIHNjaGVtYS5wcmUoJ2ZpbmRPbmVBbmRVcGRhdGUnLCBmdW5jdGlvbigpIHsgcmV0dXJuIGF1dG9wb3B1bGF0ZUhhbmRsZXIuY2FsbCh0aGlzKTsgfSk7XG4gICAgc2NoZW1hLnBvc3QoJ2ZpbmRPbmVBbmRVcGRhdGUnLCBmdW5jdGlvbihyZXMpIHsgcmV0dXJuIGF1dG9wb3B1bGF0ZURpc2NyaW1pbmF0b3JzLmNhbGwodGhpcywgcmVzKTsgfSk7XG4gIH1cbiAgaWYgKHRlc3RGdW5jdGlvbignZmluZE9uZUFuZERlbGV0ZScpKSB7XG4gICAgc2NoZW1hLnByZSgnZmluZE9uZUFuZERlbGV0ZScsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXV0b3BvcHVsYXRlSGFuZGxlci5jYWxsKHRoaXMpOyB9KTtcbiAgICBzY2hlbWEucG9zdCgnZmluZE9uZUFuZERlbGV0ZScsIGZ1bmN0aW9uKHJlcykgeyByZXR1cm4gYXV0b3BvcHVsYXRlRGlzY3JpbWluYXRvcnMuY2FsbCh0aGlzLCByZXMpOyB9KTtcbiAgfVxuICBpZiAodGVzdEZ1bmN0aW9uKCdmaW5kT25lQW5kUmVwbGFjZScpKSB7XG4gICAgc2NoZW1hLnByZSgnZmluZE9uZUFuZFJlcGxhY2UnLCBmdW5jdGlvbigpIHsgcmV0dXJuIGF1dG9wb3B1bGF0ZUhhbmRsZXIuY2FsbCh0aGlzKTsgfSk7XG4gICAgc2NoZW1hLnBvc3QoJ2ZpbmRPbmVBbmRSZXBsYWNlJywgZnVuY3Rpb24ocmVzKSB7IHJldHVybiBhdXRvcG9wdWxhdGVEaXNjcmltaW5hdG9ycy5jYWxsKHRoaXMsIHJlcyk7IH0pO1xuICB9XG4gIGlmICh0ZXN0RnVuY3Rpb24oJ3NhdmUnKSkge1xuICAgIHNjaGVtYS5wb3N0KCdzYXZlJywgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocGF0aHNUb1BvcHVsYXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICAvLyBTa2lwIGZvciBzdWJkb2NzLCBiZWNhdXNlIHdlIGFzc3VtZSB0aGlzIGZ1bmN0aW9uIG9ubHkgcnVucyBvblxuICAgICAgLy8gdG9wLWxldmVsIGRvY3VtZW50cy5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vd25lckRvY3VtZW50ID09PSAnZnVuY3Rpb24nICYmIHRoaXMuJGlzU3ViZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgZmluYWxQYXRocyA9IGF1dG9wb3B1bGF0ZUhhbmRsZXIuY2FsbCh0aGlzLCBvcHRpb25zID0+IHtcbiAgICAgICAgY29uc3QgcG9wID0gdGhpcy5wb3B1bGF0ZWQob3B0aW9ucy5wYXRoKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocG9wKSkge1xuICAgICAgICAgIGNvbnN0IGRvY1ZhbCA9IHRoaXMuZ2V0KG9wdGlvbnMucGF0aCk7XG4gICAgICAgICAgcmV0dXJuIGRvY1ZhbCA9PSBudWxsIHx8XG4gICAgICAgICAgICBwb3AubGVuZ3RoICE9PSBkb2NWYWwubGVuZ3RoIHx8XG4gICAgICAgICAgICBwb3Auc29tZSh2ID0+IHYgPT0gbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLnBvcHVsYXRlKGZpbmFsUGF0aHMpO1xuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBhdXRvcG9wdWxhdGVEaXNjcmltaW5hdG9ycyhyZXMpIHtcbiAgaWYgKHJlcyA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0aGlzLl9tb25nb29zZU9wdGlvbnMgIT0gbnVsbCAmJiB0aGlzLl9tb25nb29zZU9wdGlvbnMubGVhbikge1xuICAgIC8vIElmIGxlYW4sIHdlIGRvbid0IGhhdmUgYSBnb29kIHdheSB0byBmaWd1cmUgb3V0IHRoZSBkaXNjcmltaW5hdG9yXG4gICAgLy8gc2NoZW1hLCBhbmQgc28gc2tpcCBhdXRvcG9wdWxhdGluZy5cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHJlcykpIHtcbiAgICByZXMgPSBbcmVzXTtcbiAgfVxuXG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JzID0gbmV3IE1hcCgpO1xuICBmb3IgKGNvbnN0IGRvYyBvZiByZXMpIHtcbiAgICBpZiAoZG9jLmNvbnN0cnVjdG9yLmJhc2VNb2RlbE5hbWUgIT0gbnVsbCkge1xuICAgICAgY29uc3QgZGlzY3JpbWluYXRvck1vZGVsID0gZG9jLmNvbnN0cnVjdG9yO1xuICAgICAgY29uc3QgbW9kZWxOYW1lID0gZGlzY3JpbWluYXRvck1vZGVsLm1vZGVsTmFtZTtcblxuICAgICAgaWYgKCFkaXNjcmltaW5hdG9ycy5oYXMobW9kZWxOYW1lKSkge1xuICAgICAgICBjb25zdCBwYXRoc1RvUG9wdWxhdGUgPSBnZXRQYXRoc1RvUG9wdWxhdGUoZGlzY3JpbWluYXRvck1vZGVsLnNjaGVtYSkuXG4gICAgICAgICAgZmlsdGVyKHAgPT4gIWRvYy5wb3B1bGF0ZWQocC5vcHRpb25zLnBhdGgpKTtcblxuICAgICAgICBkaXNjcmltaW5hdG9ycy5zZXQobW9kZWxOYW1lLCB7XG4gICAgICAgICAgbW9kZWw6IGRpc2NyaW1pbmF0b3JNb2RlbCxcbiAgICAgICAgICBkb2NzOiBbXSxcbiAgICAgICAgICBwYXRoc1RvUG9wdWxhdGU6IHBhdGhzVG9Qb3B1bGF0ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsTWFwID0gZGlzY3JpbWluYXRvcnMuZ2V0KG1vZGVsTmFtZSk7XG4gICAgICBtb2RlbE1hcC5kb2NzLnB1c2goZG9jKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gUHJvbWlzZS5hbGwoQXJyYXkuZnJvbShkaXNjcmltaW5hdG9ycy52YWx1ZXMoKSkubWFwKG1vZGVsTWFwID0+IHtcbiAgICBjb25zdCBwYXRoc1RvUG9wdWxhdGUgPSBtb2RlbE1hcC5wYXRoc1RvUG9wdWxhdGUuXG4gICAgICBtYXAocCA9PiBwcm9jZXNzT3B0aW9uLmNhbGwodGhpcywgcC5hdXRvcG9wdWxhdGUsIHAub3B0aW9ucykpLlxuICAgICAgZmlsdGVyKHYgPT4gISF2KTtcbiAgICByZXR1cm4gbW9kZWxNYXAubW9kZWwucG9wdWxhdGUobW9kZWxNYXAuZG9jcywgcGF0aHNUb1BvcHVsYXRlKTtcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBnZXRQYXRoc1RvUG9wdWxhdGUoc2NoZW1hKSB7XG4gIGNvbnN0IHBhdGhzVG9Qb3B1bGF0ZSA9IFtdO1xuICBjb25zdCBzY2hlbWFTdGFjayA9IG5ldyBXZWFrTWFwKCk7XG4gIGVhY2hQYXRoUmVjdXJzaXZlKHNjaGVtYSwgZnVuY3Rpb24ocGF0aG5hbWUsIHNjaGVtYVR5cGUpIHtcbiAgICBsZXQgb3B0aW9uO1xuICAgIGlmIChzY2hlbWFUeXBlLm9wdGlvbnMgJiYgc2NoZW1hVHlwZS5vcHRpb25zLmF1dG9wb3B1bGF0ZSkge1xuICAgICAgb3B0aW9uID0gc2NoZW1hVHlwZS5vcHRpb25zLmF1dG9wb3B1bGF0ZTtcbiAgICAgIHBhdGhzVG9Qb3B1bGF0ZS5wdXNoKHtcbiAgICAgICAgb3B0aW9uczogZGVmYXVsdE9wdGlvbnMocGF0aG5hbWUsIHNjaGVtYVR5cGUub3B0aW9ucyksXG4gICAgICAgIGF1dG9wb3B1bGF0ZTogb3B0aW9uXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHNjaGVtYVR5cGUub3B0aW9ucyAmJlxuICAgICAgICBzY2hlbWFUeXBlLm9wdGlvbnMudHlwZSAmJlxuICAgICAgICBzY2hlbWFUeXBlLm9wdGlvbnMudHlwZVswXSAmJlxuICAgICAgICBzY2hlbWFUeXBlLm9wdGlvbnMudHlwZVswXS5hdXRvcG9wdWxhdGUpIHtcbiAgICAgIG9wdGlvbiA9IHNjaGVtYVR5cGUub3B0aW9ucy50eXBlWzBdLmF1dG9wb3B1bGF0ZTtcbiAgICAgIHBhdGhzVG9Qb3B1bGF0ZS5wdXNoKHtcbiAgICAgICAgb3B0aW9uczogZGVmYXVsdE9wdGlvbnMocGF0aG5hbWUsIHNjaGVtYVR5cGUub3B0aW9ucy50eXBlWzBdKSxcbiAgICAgICAgYXV0b3BvcHVsYXRlOiBvcHRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgbnVsbCwgc2NoZW1hU3RhY2spO1xuXG4gIHJldHVybiBwYXRoc1RvUG9wdWxhdGU7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRPcHRpb25zKHBhdGhuYW1lLCB2KSB7XG4gIGNvbnN0IHJldCA9IHsgcGF0aDogcGF0aG5hbWUsIG9wdGlvbnM6IHsgbWF4RGVwdGg6IDEwIH0gfTtcbiAgaWYgKHYucmVmICE9IG51bGwpIHtcbiAgICByZXQubW9kZWwgPSB2LnJlZjtcbiAgICByZXQucmVmID0gdi5yZWY7XG4gIH1cbiAgaWYgKHYucmVmUGF0aCAhPSBudWxsKSB7XG4gICAgcmV0LnJlZlBhdGggPSB2LnJlZlBhdGg7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc09wdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHJldHVybiBoYW5kbGVGdW5jdGlvbi5jYWxsKHRoaXMsIHZhbHVlLCBvcHRpb25zKTtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgcmV0dXJuIGhhbmRsZU9iamVjdC5jYWxsKHRoaXMsIHZhbHVlLCBvcHRpb25zKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGhhbmRsZVByaW1pdGl2ZS5jYWxsKHRoaXMsIHZhbHVlLCBvcHRpb25zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVQcmltaXRpdmUodmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlT2JqZWN0KHZhbHVlLCBvcHRpb25zVG9Vc2UpIHtcbiAgLy8gU3BlY2lhbCBjYXNlOiBzdXBwb3J0IHRvcC1sZXZlbCBgbWF4RGVwdGhgXG4gIGlmICh2YWx1ZS5tYXhEZXB0aCAhPSBudWxsKSB7XG4gICAgb3B0aW9uc1RvVXNlLm9wdGlvbnMgPSBvcHRpb25zVG9Vc2Uub3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zVG9Vc2Uub3B0aW9ucy5tYXhEZXB0aCA9IHZhbHVlLm1heERlcHRoO1xuICAgIGRlbGV0ZSB2YWx1ZS5tYXhEZXB0aDtcbiAgfVxuICBvcHRpb25zVG9Vc2UgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zVG9Vc2UsIHZhbHVlKTtcblxuICByZXR1cm4gb3B0aW9uc1RvVXNlO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVGdW5jdGlvbihmbiwgb3B0aW9ucykge1xuICBjb25zdCB2YWwgPSBmbi5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICByZXR1cm4gcHJvY2Vzc09wdGlvbi5jYWxsKHRoaXMsIHZhbCwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGVhY2hQYXRoUmVjdXJzaXZlKHNjaGVtYSwgaGFuZGxlciwgcGF0aCwgc2NoZW1hU3RhY2spIHtcblxuICBpZiAoc2NoZW1hU3RhY2suaGFzKHNjaGVtYSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFwYXRoKSB7XG4gICAgcGF0aCA9IFtdO1xuICB9XG4gIHNjaGVtYVN0YWNrLnNldChzY2hlbWEsIHRydWUpO1xuXG4gIHNjaGVtYS5lYWNoUGF0aChmdW5jdGlvbihwYXRobmFtZSwgc2NoZW1hVHlwZSkge1xuICAgIHBhdGgucHVzaChwYXRobmFtZSk7XG4gICAgaWYgKHNjaGVtYVR5cGUuc2NoZW1hKSB7XG4gICAgICBlYWNoUGF0aFJlY3Vyc2l2ZShzY2hlbWFUeXBlLnNjaGVtYSwgaGFuZGxlciwgcGF0aCwgc2NoZW1hU3RhY2spO1xuXG4gICAgICBpZiAoc2NoZW1hVHlwZS5zY2hlbWEuZGlzY3JpbWluYXRvcnMgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGNvbnN0IGRpc2NyaW1pbmF0b3JOYW1lIG9mIE9iamVjdC5rZXlzKHNjaGVtYVR5cGUuc2NoZW1hLmRpc2NyaW1pbmF0b3JzKSkge1xuICAgICAgICAgIGVhY2hQYXRoUmVjdXJzaXZlKFxuICAgICAgICAgICAgc2NoZW1hVHlwZS5zY2hlbWEuZGlzY3JpbWluYXRvcnNbZGlzY3JpbWluYXRvck5hbWVdLFxuICAgICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBzY2hlbWFTdGFja1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNjaGVtYVR5cGUuJGlzTW9uZ29vc2VBcnJheSAmJiBzY2hlbWFUeXBlLiRlbWJlZGRlZFNjaGVtYVR5cGUuJGlzTW9uZ29vc2VBcnJheSkge1xuICAgICAgd2hpbGUgKHNjaGVtYVR5cGUgIT0gbnVsbCAmJiBzY2hlbWFUeXBlLiRpc01vbmdvb3NlQXJyYXkgJiYgIXNjaGVtYVR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICAgIHNjaGVtYVR5cGUgPSBzY2hlbWFUeXBlLiRlbWJlZGRlZFNjaGVtYVR5cGU7XG4gICAgICB9XG4gICAgICBpZiAoc2NoZW1hVHlwZSAhPSBudWxsICYmIHNjaGVtYVR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICAgIGVhY2hQYXRoUmVjdXJzaXZlKHNjaGVtYVR5cGUuc2NoZW1hLCBoYW5kbGVyLCBwYXRoLCBzY2hlbWFTdGFjayk7XG5cbiAgICAgICAgaWYgKHNjaGVtYVR5cGUuc2NoZW1hLmRpc2NyaW1pbmF0b3JzICE9IG51bGwpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGRpc2NyaW1pbmF0b3JOYW1lIG9mIE9iamVjdC5rZXlzKHNjaGVtYVR5cGUuc2NoZW1hLmRpc2NyaW1pbmF0b3JzKSkge1xuICAgICAgICAgICAgZWFjaFBhdGhSZWN1cnNpdmUoXG4gICAgICAgICAgICAgIHNjaGVtYVR5cGUuc2NoZW1hLmRpc2NyaW1pbmF0b3JzW2Rpc2NyaW1pbmF0b3JOYW1lXSxcbiAgICAgICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgc2NoZW1hU3RhY2tcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZXIocGF0aC5qb2luKCcuJyksIHNjaGVtYVR5cGUpO1xuICAgIH1cbiAgICBwYXRoLnBvcCgpO1xuICB9KTtcbiAgc2NoZW1hU3RhY2suZGVsZXRlKHNjaGVtYSk7XG4gIGlmIChzY2hlbWEudmlydHVhbHMpIHtcbiAgICBPYmplY3Qua2V5cyhzY2hlbWEudmlydHVhbHMpLmZvckVhY2goZnVuY3Rpb24ocGF0aG5hbWUpIHtcbiAgICAgIHBhdGgucHVzaChwYXRobmFtZSk7XG4gICAgICBoYW5kbGVyKHBhdGguam9pbignLicpLCBzY2hlbWEudmlydHVhbHNbcGF0aG5hbWVdKTtcbiAgICAgIHBhdGgucG9wKCk7XG4gICAgfSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/mongoose-autopopulate/index.js\n");

/***/ })

};
;